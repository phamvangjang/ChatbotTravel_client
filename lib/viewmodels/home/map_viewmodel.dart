import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:geolocator/geolocator.dart';
import 'package:http/http.dart' as http;
import 'package:latlong2/latlong.dart';

import '../../models/attraction_model.dart';
import '../../models/itinerary_item.dart';
import '../../services/home/attraction_service.dart';

class MapViewModel extends ChangeNotifier {
  // Services
  //final LocationService _locationService = LocationService();
  final AttractionService _attractionService = AttractionService();

  // Mapbox access token
  final String mapboxAccessToken = dotenv.env["MAPBOX_ACCESS_TOKEN"]!;

  // Mapbox style URL
  final String mapboxStyleUrl = dotenv.env["MAPBOX_STYLE_URL_V2"]!;

  // Mapbox directions API URL
  final String directionsApiUrl = dotenv.env["DIRECTIONS_API_URL_V2"]!;

  // Tr·∫°ng th√°i
  bool _isLoading = true;
  bool get isLoading => _isLoading;

  // V·ªã tr√≠ hi·ªán t·∫°i
  Position? _currentPosition;
  Position? get currentPosition => _currentPosition;

  // V·ªã tr√≠ ban ƒë·∫ßu (m·∫∑c ƒë·ªãnh: H·ªì Ch√≠ Minh)
  LatLng _initialPosition = LatLng(10.7769, 106.7009);
  LatLng get initialPosition => _initialPosition;

  // N·ªôi dung tin nh·∫Øn
  List<String> _places = [];
  List<String> get places => _places;

  // ID cu·ªôc tr√≤ chuy·ªán
  int _conversationId = 0;
  int get conversationId => _conversationId;

  // Ng√¥n ng·ªØ c·ªßa bot message
  String _language = '';
  String get language => _language;

  // Danh s√°ch ƒë·ªãa ƒëi·ªÉm du l·ªãch
  List<Attraction> _detectedAttractions = [];
  List<Attraction> get detectedAttractions => _detectedAttractions;

  // ƒê·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn
  Attraction? _selectedAttraction;
  Attraction? get selectedAttraction => _selectedAttraction;

  // Markers tr√™n b·∫£n ƒë·ªì
  List<Marker> _markers = [];
  List<Marker> get markers => _markers;

  // Polylines tr√™n b·∫£n ƒë·ªì
  List<Polyline> _polylines = [];
  List<Polyline> get polylines => _polylines;

  // L·ªãch tr√¨nh theo ng√†y
  final Map<DateTime, List<ItineraryItem>> _dailyItineraries = {};
  Map<DateTime, List<ItineraryItem>> get dailyItineraries => _dailyItineraries;

  // Ng√†y ƒë∆∞·ª£c ch·ªçn
  DateTime _selectedDate = DateTime.now();
  DateTime get selectedDate => _selectedDate;

  // L·ªãch tr√¨nh c·ªßa ng√†y ƒë∆∞·ª£c ch·ªçn
  List<ItineraryItem> get todayItinerary {
    final dateKey = DateTime(
      _selectedDate.year,
      _selectedDate.month,
      _selectedDate.day,
    );
    return _dailyItineraries[dateKey] ?? [];
  }

  // Controller cho MapboxMap
  MapController? _mapController;
  MapController? get mapController => _mapController;

  bool _isMapControllerActive = true;
  // Ph∆∞∆°ng th·ª©c ƒë·ªÉ ki·ªÉm tra v√† ƒë·∫∑t l·∫°i controller
  void setMapControllerActive(bool isActive) {
    _isMapControllerActive = isActive;
    if (!isActive && _mapController != null) {
      // ƒê·∫∑t l·∫°i controller khi widget b·ªã h·ªßy
      _mapController = null;
    }
  }

  // Kh·ªüi t·∫°o
  Future<void> initialize(List<String> places, int conversationId, String language) async {
    // Decode Unicode cho places tr∆∞·ªõc khi g√°n
    _places = places.map((place) => _decodeUnicode(place)).toList();
    print("üîç Decoded places: $_places");
    
    _conversationId = conversationId;
    _language = language;
    _isLoading = true;
    notifyListeners();

    // T·∫°o MapController
    _mapController = MapController();

    // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
    await _getCurrentLocationAndSetInitial();

    // Ph√°t hi·ªán ƒë·ªãa ƒëi·ªÉm t·ª´ n·ªôi dung tin nh·∫Øn
    await _detectAttractionsFromMessage();

    _isLoading = false;
    notifyListeners();
  }

  Future<void> _getCurrentLocationAndSetInitial() async{
    try{
      print('üîç ƒêang l·∫•y v·ªã tr√≠ hi·ªán t·∫°i...');

      // Ki·ªÉm tra quy·ªÅn truy c·∫≠p v·ªã tr√≠
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Quy·ªÅn truy c·∫≠p v·ªã tr√≠ b·ªã t·ª´ ch·ªëi');
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Quy·ªÅn truy c·∫≠p v·ªã tr√≠ b·ªã t·ª´ ch·ªëi vƒ©nh vi·ªÖn');
        return;
      }

      /*
      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i v·ªõi ƒë·ªô ch√≠nh x√°c cao
      _currentPosition = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: Duration(seconds: 10),
      );
       */
      // S·ª≠ d·ª•ng LocationSettings m·ªõi
      LocationSettings locationSettings = LocationSettings(
        accuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10)
      );

      _currentPosition = await Geolocator.getCurrentPosition(
        locationSettings: locationSettings,
      );

      if (_currentPosition != null) {
        _initialPosition = LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );

        print('‚úÖ ƒê√£ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}');
        print('üìç V·ªã tr√≠ ban ƒë·∫ßu ƒë∆∞·ª£c c·∫≠p nh·∫≠t: $_initialPosition');
      } else {
        print('‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i, s·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh');
      }
    }catch (e) {
      print('‚ùå L·ªói khi l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: $e');
      print('üìç S·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh: $_initialPosition');
    }
  }

  // Ph√°t hi·ªán ƒë·ªãa ƒëi·ªÉm t·ª´ n·ªôi dung tin nh·∫Øn
  Future<void> _detectAttractionsFromMessage() async {
    try {
      if (_places.isNotEmpty) {        
        _detectedAttractions = await _attractionService
            .detectAttractionsFromMessage(_places, language: _language);
        print("‚ÑπÔ∏è _detectAttractionsFromMessage: get location from places with language: $_language");
      } else {
        // N·∫øu kh√¥ng c√≥ places, l·∫•y ƒë·ªãa ƒëi·ªÉm g·∫ßn ƒë√≥
        if (_currentPosition != null) {
          LatLng currentLatLng = LatLng(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          );
          _detectedAttractions = await _attractionService.getNearbyAttractions(
            currentLatLng,
          );
          print("‚ÑπÔ∏è _detectAttractionsFromMessage: nothing places get getNearbyAttractions");
        } else {
          // L·∫•y t·∫•t c·∫£ ƒë·ªãa ƒëi·ªÉm
          print("‚ÑπÔ∏è _detectAttractionsFromMessage: get all location");
          _detectedAttractions = await _attractionService.getAllAttractions();
        }
      }

      // T·∫°o markers cho c√°c ƒë·ªãa ƒëi·ªÉm
      _updateMarkers();
    } catch (e) {
      print('Error detecting attractions: $e');
      // Fallback: l·∫•y t·∫•t c·∫£ ƒë·ªãa ƒëi·ªÉm
      _detectedAttractions = await _attractionService.getAllAttractions();
      _updateMarkers();
    }
  }

  // C·∫≠p nh·∫≠t markers
  void _updateMarkers() {
    _markers = [];

    // Th√™m marker cho v·ªã tr√≠ hi·ªán t·∫°i
    if (_currentPosition != null) {
      _markers.add(
        Marker(
          point: LatLng(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          ),
          width: 40,
          height: 40,
          builder:
              (context) => Container(
                decoration: BoxDecoration(
                  color: Colors.blue,
                  shape: BoxShape.circle,
                  border: Border.all(color: Colors.white, width: 2),
                ),
                child: const Icon(
                  Icons.my_location,
                  color: Colors.white,
                  size: 20,
                ),
              ),
        ),
      );
    }

    // L·∫•y danh s√°ch c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh c·ªßa ng√†y h√¥m nay
    final itineraryItems = todayItinerary;
    final itineraryAttractionIds = itineraryItems.map((item) => item.attraction.id).toSet();

    // T·∫°o map ƒë·ªÉ l∆∞u tr·ªØ th·ª© t·ª± c·ªßa c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh
    final Map<String, int> attractionOrder = {};
    for (int i = 0; i < itineraryItems.length; i++) {
      attractionOrder[itineraryItems[i].attraction.id] = i + 1;
    }

    // Th√™m markers cho c√°c ƒë·ªãa ƒëi·ªÉm
    for (var attraction in _detectedAttractions) {
      final isSelected = _selectedAttraction?.id == attraction.id;
      final isInItinerary = itineraryAttractionIds.contains(attraction.id);
      final orderNumber = isInItinerary ? attractionOrder[attraction.id] : null;

      _markers.add(
        Marker(
          point: attraction.location,
          width: 40,
          height: 40,
          builder: (context) => GestureDetector(
            onTap: () => selectAttraction(attraction),
            child: Container(
              decoration: BoxDecoration(
                color: isSelected
                    ? Colors.green
                    : isInItinerary
                    ? Colors.orange
                    : Colors.red,
                shape: BoxShape.circle,
                border: Border.all(color: Colors.white, width: 2),
              ),
              child: isInItinerary
                  ? Stack(
                alignment: Alignment.center,
                children: [
                  Icon(
                    Icons.schedule,
                    color: Colors.white,
                    size: isSelected ? 20 : 16,
                  ),
                  Positioned(
                    top: 2,
                    right: 2,
                    child: Container(
                      padding: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        shape: BoxShape.circle,
                      ),
                      child: Text(
                        '$orderNumber',
                        style: TextStyle(
                          color: Colors.orange,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              )
                  : Icon(
                Icons.location_on,
                color: Colors.white,
                size: isSelected ? 24 : 20,
              ),
            ),
          ),
        ),
      );
    }

    // Th√™m markers cho c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh m√† kh√¥ng c√≥ trong k·∫øt qu·∫£ t√¨m ki·∫øm
    final searchAttractionIds = _detectedAttractions.map((a) => a.id).toSet();
    for (var item in itineraryItems) {
      // N·∫øu ƒë·ªãa ƒëi·ªÉm ƒë√£ c√≥ trong k·∫øt qu·∫£ t√¨m ki·∫øm th√¨ b·ªè qua
      if (searchAttractionIds.contains(item.attraction.id)) continue;

      final isSelected = _selectedAttraction?.id == item.attraction.id;
      final orderNumber = attractionOrder[item.attraction.id];

      _markers.add(
        Marker(
          point: item.attraction.location,
          width: 40,
          height: 40,
          builder: (context) => GestureDetector(
            onTap: () => selectAttraction(item.attraction),
            child: Container(
              decoration: BoxDecoration(
                color: isSelected ? Colors.green : Colors.orange,
                shape: BoxShape.circle,
                border: Border.all(color: Colors.white, width: 2),
              ),
              child: Stack(
                alignment: Alignment.center,
                children: [
                  Icon(
                    Icons.schedule,
                    color: Colors.white,
                    size: isSelected ? 20 : 16,
                  ),
                  Positioned(
                    top: 2,
                    right: 2,
                    child: Container(
                      padding: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        shape: BoxShape.circle,
                      ),
                      child: Text(
                        '$orderNumber',
                        style: TextStyle(
                          color: Colors.orange,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    notifyListeners();
  }

  // Ki·ªÉm tra ƒë·ªãa ƒëi·ªÉm c√≥ trong l·ªãch tr√¨nh h√¥m nay kh√¥ng
  bool _isAttractionInTodayItinerary(Attraction attraction) {
    return todayItinerary.any((item) => item.attraction.id == attraction.id);
  }

  // Ch·ªçn ƒë·ªãa ƒëi·ªÉm
  Future<void> selectAttraction(Attraction attraction) async {
    _selectedAttraction = attraction;
    _updateMarkers();

    // Di chuy·ªÉn b·∫£n ƒë·ªì ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn
    if (_mapController != null && _isMapControllerActive) {
      try {
        _mapController!.move(attraction.location, 15.0);
      } catch (e) {
        print('‚ùå L·ªói khi di chuy·ªÉn b·∫£n ƒë·ªì: $e');
        _mapController = null;
      }
    }

    // V·∫Ω ƒë∆∞·ªùng ƒëi t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn
    if (_currentPosition != null) {
      await _getDirections(
        LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
        attraction.location,
      );
    }

    notifyListeners();
  }

  // L·∫•y ch·ªâ ƒë∆∞·ªùng t·ª´ Mapbox API
  Future<void> _getDirections(LatLng start, LatLng end) async {
    try {
      final response = await http.get(
        Uri.parse(
          '$directionsApiUrl/${start.longitude},${start.latitude};${end.longitude},${end.latitude}?geometries=geojson&access_token=$mapboxAccessToken',
        ),
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);

        if (data['routes'] != null && data['routes'].isNotEmpty) {
          final route = data['routes'][0];
          final geometry = route['geometry'];

          if (geometry != null && geometry['coordinates'] != null) {
            final List<dynamic> coords = geometry['coordinates'];
            final List<LatLng> points =
                coords.map((coord) {
                  return LatLng(coord[1], coord[0]);
                }).toList();

            _polylines = [
              Polyline(points: points, color: Colors.blue, strokeWidth: 4.0),
            ];

            notifyListeners();
          }
        }
      }
    } catch (e) {
      print('Error getting directions: $e');
    }
  }

  // V·∫º ƒê∆Ø·ªúNG N·ªêI C√ÅC ƒê·ªäA ƒêI·ªÇM TRONG L·ªäCH TR√åNH
  Future<void> _drawItineraryRoute() async {
    try {
      final itinerary = todayItinerary;
      if (itinerary.length < 2) {
        // N·∫øu √≠t h∆°n 2 ƒë·ªãa ƒëi·ªÉm, ch·ªâ v·∫Ω t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë·∫ßu ti√™n
        if (itinerary.length == 1 && _currentPosition != null) {
          await _getDirections(
            LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
            itinerary.first.attraction.location,
          );
        }
        return;
      }

      print('üó∫Ô∏è ƒêang v·∫Ω tuy·∫øn ƒë∆∞·ªùng cho ${itinerary.length} ƒë·ªãa ƒëi·ªÉm...');

      List<Polyline> itineraryPolylines = [];

      // T·∫°o danh s√°ch c√°c ƒëi·ªÉm theo th·ª© t·ª± th·ªùi gian
      List<LatLng> waypoints = [];

      // Th√™m v·ªã tr√≠ hi·ªán t·∫°i l√†m ƒëi·ªÉm b·∫Øt ƒë·∫ßu (n·∫øu c√≥)
      if (_currentPosition != null) {
        waypoints.add(LatLng(_currentPosition!.latitude, _currentPosition!.longitude));
      }

      // Th√™m c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh theo th·ª© t·ª± th·ªùi gian
      for (var item in itinerary) {
        waypoints.add(item.attraction.location);
      }

      // V·∫Ω ƒë∆∞·ªùng n·ªëi t·ª´ng c·∫∑p ƒëi·ªÉm li√™n ti·∫øp
      for (int i = 0; i < waypoints.length - 1; i++) {
        final start = waypoints[i];
        final end = waypoints[i + 1];

        try {
          final response = await http.get(
            Uri.parse(
              '$directionsApiUrl/${start.longitude},${start.latitude};${end.longitude},${end.latitude}?geometries=geojson&access_token=$mapboxAccessToken',
            ),
          );

          if (response.statusCode == 200) {
            final data = json.decode(response.body);

            if (data['routes'] != null && data['routes'].isNotEmpty) {
              final route = data['routes'][0];
              final geometry = route['geometry'];

              if (geometry != null && geometry['coordinates'] != null) {
                final List<dynamic> coords = geometry['coordinates'];
                final List<LatLng> points = coords.map((coord) {
                  return LatLng(coord[1], coord[0]);
                }).toList();

                // M√†u s·∫Øc kh√°c nhau cho t·ª´ng ƒëo·∫°n ƒë∆∞·ªùng
                Color segmentColor;
                if (i == 0 && _currentPosition != null) {
                  segmentColor = Colors.blue; // T·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒëi·ªÉm ƒë·∫ßu ti√™n
                } else {
                  segmentColor = Colors.green; // Gi·ªØa c√°c ƒëi·ªÉm trong l·ªãch tr√¨nh
                }

                itineraryPolylines.add(
                  Polyline(
                    points: points,
                    color: segmentColor,
                    strokeWidth: 4.0,
                  ),
                );
              }
            }
          }
        } catch (e) {
          print('‚ùå L·ªói v·∫Ω ƒë∆∞·ªùng ƒëo·∫°n ${i + 1}: $e');
        }

        // Delay nh·ªè ƒë·ªÉ tr√°nh spam API
        await Future.delayed(Duration(milliseconds: 200));
      }

      _polylines = itineraryPolylines;
      print('‚úÖ ƒê√£ v·∫Ω ${itineraryPolylines.length} ƒëo·∫°n ƒë∆∞·ªùng');
      notifyListeners();

    } catch (e) {
      print('‚ùå L·ªói v·∫Ω tuy·∫øn ƒë∆∞·ªùng l·ªãch tr√¨nh: $e');
    }
  }

  // Kh·ªüi t·∫°o MapController
  void onMapCreated() {
    _mapController ??= MapController();
    _isMapControllerActive = true;
    notifyListeners();
  }

  // Ch·ªçn ng√†y
  void selectDate(DateTime date) {
    _selectedDate = date;
    // C·∫≠p nh·∫≠t markers ƒë·ªÉ hi·ªÉn th·ªã ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh ng√†y ƒë∆∞·ª£c ch·ªçn
    _updateMarkers();
    // V·∫Ω l·∫°i ƒë∆∞·ªùng ƒëi cho ng√†y ƒë∆∞·ª£c ch·ªçn
    _drawItineraryRoute();
    notifyListeners();
  }

  // Th√™m v√†o l·ªãch tr√¨nh
  void addToItinerary(
    Attraction attraction, {
    required DateTime date,
    required TimeOfDay time,
    String notes = '',
    Duration? estimatedDuration,
  }) {
    final dateKey = DateTime(date.year, date.month, date.day);
    final visitTime = DateTime(
      date.year,
      date.month,
      date.day,
      time.hour,
      time.minute,
    );

    // T·∫°o ItineraryItem v·ªõi th√¥ng tin ƒë·∫ßy ƒë·ªß
    final item = ItineraryItem(
      attraction: attraction,
      visitTime: visitTime,
      estimatedDuration: estimatedDuration ?? const Duration(hours: 2),
      notes: notes,
      createdAt: DateTime.now(),
    );

    if (_dailyItineraries.containsKey(dateKey)) {
      _dailyItineraries[dateKey]!.add(item);
      // S·∫Øp x·∫øp theo th·ªùi gian
      _dailyItineraries[dateKey]!.sort(
        (a, b) => a.visitTime.compareTo(b.visitTime),
      );
    } else {
      _dailyItineraries[dateKey] = [item];
    }

    // C·∫≠p nh·∫≠t markers
    _updateMarkers();

    // V·∫º ƒê∆Ø·ªúNG N·ªêI C√ÅC ƒê·ªäA ƒêI·ªÇM TRONG L·ªäCH TR√åNH
    if (dateKey == DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day)) {
      _drawItineraryRoute();
    }

    // In ra th√¥ng tin chi ti·∫øt
    print('‚úÖ ƒê√É TH√äM V√ÄO L·ªäCH TR√åNH:');
    print('üìç ƒê·ªãa ƒëi·ªÉm: ${attraction.name}');
    print('üìÖ Ng√†y: ${date.day}/${date.month}/${date.year}');
    print('‚è∞ Th·ªùi gian: ${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}');
    print('‚è±Ô∏è Th·ªùi l∆∞·ª£ng: ${estimatedDuration?.inHours ?? 2} gi·ªù');
    if (notes.isNotEmpty) {
      print('üìù Ghi ch√∫: $notes');
    }
    print('üí∞ Gi√° v√©: ${attraction.price != null ? '${attraction.price!.toInt()} VND' : 'Mi·ªÖn ph√≠'}');
    print('‚≠ê Rating: ${attraction.rating}/5');
    print('üìç ƒê·ªãa ch·ªâ: ${attraction.address}');
    print('üìä T·ªïng s·ªë ƒë·ªãa ƒëi·ªÉm trong ng√†y: ${_dailyItineraries[dateKey]?.length ?? 0}');
    print('-' * 50);

    notifyListeners();
  }

  // X√≥a kh·ªèi l·ªãch tr√¨nh
  void removeFromItinerary(ItineraryItem item) {
    final dateKey = DateTime(
      item.visitTime.year,
      item.visitTime.month,
      item.visitTime.day,
    );

    if (_dailyItineraries.containsKey(dateKey)) {
      _dailyItineraries[dateKey]!.remove(item);

      if (_dailyItineraries[dateKey]!.isEmpty) {
        _dailyItineraries.remove(dateKey);
      }

      // C·∫≠p nh·∫≠t markers
      _updateMarkers();

      // V·∫Ω l·∫°i ƒë∆∞·ªùng ƒëi
      if (dateKey == DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day)) {
        _drawItineraryRoute();
      }

      // In ra th√¥ng tin chi ti·∫øt
      print('‚ùå ƒê√É X√ìA KH·ªéI L·ªäCH TR√åNH:');
      print('üìç ƒê·ªãa ƒëi·ªÉm: ${item.attraction.name}');
      print('üìÖ Ng√†y: ${item.visitTime.day}/${item.visitTime.month}/${item.visitTime.year}');
      print('‚è∞ Th·ªùi gian: ${item.visitTime.hour.toString().padLeft(2, '0')}:${item.visitTime.minute.toString().padLeft(2, '0')}');
      print('‚è±Ô∏è Th·ªùi l∆∞·ª£ng: ${item.estimatedDuration.inHours} gi·ªù');
      if (item.notes.isNotEmpty) {
        print('üìù Ghi ch√∫: ${item.notes}');
      }
      print('üí∞ Gi√° v√©: ${item.attraction.price != null ? '${item.attraction.price!.toInt()} VND' : 'Mi·ªÖn ph√≠'}');
      print('‚≠ê Rating: ${item.attraction.rating}/5');
      print('üìç ƒê·ªãa ch·ªâ: ${item.attraction.address}');
      print('üìä S·ªë ƒë·ªãa ƒëi·ªÉm c√≤n l·∫°i trong ng√†y: ${_dailyItineraries[dateKey]?.length ?? 0}');
      print('-' * 50);

      notifyListeners();
    }
  }

  // C·∫≠p nh·∫≠t item trong l·ªãch tr√¨nh
  void updateItineraryItem(ItineraryItem oldItem, ItineraryItem newItem) {
    final oldDateKey = DateTime(
      oldItem.visitTime.year,
      oldItem.visitTime.month,
      oldItem.visitTime.day,
    );
    final newDateKey = DateTime(
      newItem.visitTime.year,
      newItem.visitTime.month,
      newItem.visitTime.day,
    );

    // X√≥a item c≈©
    if (_dailyItineraries.containsKey(oldDateKey)) {
      _dailyItineraries[oldDateKey]!.remove(oldItem);

      if (_dailyItineraries[oldDateKey]!.isEmpty) {
        _dailyItineraries.remove(oldDateKey);
      }
    }

    // Th√™m item m·ªõi
    if (_dailyItineraries.containsKey(newDateKey)) {
      _dailyItineraries[newDateKey]!.add(newItem);
      _dailyItineraries[newDateKey]!.sort(
        (a, b) => a.visitTime.compareTo(b.visitTime),
      );
    } else {
      _dailyItineraries[newDateKey] = [newItem];
    }

    // C·∫≠p nh·∫≠t markers v√† v·∫Ω l·∫°i ƒë∆∞·ªùng
    _updateMarkers();
    if (newDateKey == DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day)) {
      _drawItineraryRoute();
    }

    // In ra th√¥ng tin chi ti·∫øt
    print('üîÑ ƒê√É C·∫¨P NH·∫¨T L·ªäCH TR√åNH:');
    print('üìç ƒê·ªãa ƒëi·ªÉm: ${newItem.attraction.name}');
    print('üìÖ Ng√†y c≈©: ${oldItem.visitTime.day}/${oldItem.visitTime.month}/${oldItem.visitTime.year}');
    print('üìÖ Ng√†y m·ªõi: ${newItem.visitTime.day}/${newItem.visitTime.month}/${newItem.visitTime.year}');
    print('‚è∞ Th·ªùi gian c≈©: ${oldItem.visitTime.hour.toString().padLeft(2, '0')}:${oldItem.visitTime.minute.toString().padLeft(2, '0')}');
    print('‚è∞ Th·ªùi gian m·ªõi: ${newItem.visitTime.hour.toString().padLeft(2, '0')}:${newItem.visitTime.minute.toString().padLeft(2, '0')}');
    print('‚è±Ô∏è Th·ªùi l∆∞·ª£ng c≈©: ${oldItem.estimatedDuration.inHours} gi·ªù');
    print('‚è±Ô∏è Th·ªùi l∆∞·ª£ng m·ªõi: ${newItem.estimatedDuration.inHours} gi·ªù');
    if (oldItem.notes != newItem.notes) {
      print('üìù Ghi ch√∫ c≈©: ${oldItem.notes}');
      print('üìù Ghi ch√∫ m·ªõi: ${newItem.notes}');
    }
    print('üí∞ Gi√° v√©: ${newItem.attraction.price != null ? '${newItem.attraction.price!.toInt()} VND' : 'Mi·ªÖn ph√≠'}');
    print('‚≠ê Rating: ${newItem.attraction.rating}/5');
    print('üìç ƒê·ªãa ch·ªâ: ${newItem.attraction.address}');
    print('üìä S·ªë ƒë·ªãa ƒëi·ªÉm trong ng√†y m·ªõi: ${_dailyItineraries[newDateKey]?.length ?? 0}');
    print('-' * 50);

    notifyListeners();
  }

  // S·∫Øp x·∫øp l·∫°i l·ªãch tr√¨nh
  void reorderItinerary(int oldIndex, int newIndex) {
    if (oldIndex < newIndex) {
      newIndex -= 1;
    }

    final dateKey = DateTime(
      _selectedDate.year,
      _selectedDate.month,
      _selectedDate.day,
    );

    if (_dailyItineraries.containsKey(dateKey)) {
      final item = _dailyItineraries[dateKey]!.removeAt(oldIndex);
      _dailyItineraries[dateKey]!.insert(newIndex, item);

      // V·∫Ω l·∫°i ƒë∆∞·ªùng sau khi s·∫Øp x·∫øp
      _drawItineraryRoute();

      notifyListeners();
    }
  }

  // L∆∞u l·ªãch tr√¨nh
  Future<bool> saveItinerary() async {
    try {
      // TODO: Implement saving itinerary to backend
      await Future.delayed(const Duration(seconds: 1));
      return true;
    } catch (e) {
      print('Error saving itinerary: $e');
      return false;
    }
  }

  // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i (public method)
  Future<void> getCurrentLocation() async {
    _isLoading = true;
    notifyListeners();

    await _getCurrentLocationAndSetInitial();
    _updateMarkers();

    // Di chuy·ªÉn b·∫£n ƒë·ªì ƒë·∫øn v·ªã tr√≠ hi·ªán t·∫°i
    if (_currentPosition != null && _mapController != null && _isMapControllerActive) {
      try {
        _mapController!.move(
          LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
          15.0,
        );
      } catch (e) {
        print('‚ùå L·ªói khi di chuy·ªÉn b·∫£n ƒë·ªì: $e');
        // ƒê·∫∑t l·∫°i controller v√¨ n√≥ kh√¥ng c√≤n h·ª£p l·ªá
        _mapController = null;
      }
    }

    _isLoading = false;
    notifyListeners();
  }

  // T√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm
  Future<void> searchAttractions(String query, {String language = 'vietnamese'}) async {
    try {
      _isLoading = true;
      notifyListeners();

      LatLng? currentLocation;
      if (_currentPosition != null) {
        currentLocation = LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );
      }

      // Get the search results with language parameter
      List<Attraction> searchResults = await _attractionService.searchAttractions(
        query,
        currentLocation: currentLocation,
        language: language,
      );

      // Create a map of attraction IDs that are in the itinerary across all dates
      final Set<String> attractionsInItinerary = {};
      _dailyItineraries.forEach((date, items) {
        for (var item in items) {
          attractionsInItinerary.add(item.attraction.id);
        }
      });

      // Update the attractions list with search results
      _detectedAttractions = searchResults;

      // Update markers while preserving itinerary state
      _updateMarkers();

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      print('Error searching attractions: $e');
      _isLoading = false;
      notifyListeners();
    }
  }

  // L·∫•y ƒë·ªãa ƒëi·ªÉm theo danh m·ª•c
  Future<void> getAttractionsByCategory(String category) async {
    try {
      _isLoading = true;
      notifyListeners();

      LatLng? currentLocation;
      if (_currentPosition != null) {
        currentLocation = LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );
      }

      _detectedAttractions = await _attractionService.getAttractionsByCategory(
        category,
        currentLocation: currentLocation,
      );
      _updateMarkers();

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      print('Error getting attractions by category: $e');
      _isLoading = false;
      notifyListeners();
    }
  }

  // Reset selection
  void clearSelection() {
    _selectedAttraction = null;
    _polylines = [];
    _updateMarkers();
  }

  String _decodeUnicode(String text) {
    try {
      print("üîç Original text: $text");
      
      // B∆∞·ªõc 1: Decode Unicode escape sequences nh∆∞ \u00ed, \u00e0, etc.
      String decoded = text.replaceAllMapped(
        RegExp(r'\\u([0-9a-fA-F]{4})'),
        (match) => String.fromCharCode(int.parse(match.group(1)!, radix: 16)),
      );
      print("üîç After Unicode decode: $decoded");
      
      // B∆∞·ªõc 2: Fix UTF-8 encoding issues v·ªõi nhi·ªÅu tr∆∞·ªùng h·ª£p
      try {
        // Ki·ªÉm tra c√°c k√Ω t·ª± UTF-8 b·ªã encode sai
        if (decoded.contains('√É') || decoded.contains('√Ç') || 
            decoded.contains('√Ü') || decoded.contains('√°¬∫') || 
            decoded.contains('√°¬∫¬ª') || decoded.contains('√°¬∫¬≠')) {
          print("üîç Detected UTF-8 encoding issues, attempting multiple fixes...");
          
          // Th·ª≠ nhi·ªÅu c√°ch decode kh√°c nhau
          String result = decoded;
          
          // C√°ch 1: Latin-1 -> UTF-8
          try {
            final bytes1 = latin1.encode(decoded);
            result = utf8.decode(bytes1, allowMalformed: true);
            print("üîç After Latin-1 -> UTF-8: $result");
          } catch (e) {
            print('L·ªói Latin-1 -> UTF-8: $e');
          }
          
          // C√°ch 2: N·∫øu v·∫´n c√≤n v·∫•n ƒë·ªÅ, th·ª≠ decode l·∫°i
          if (result.contains('√É') || result.contains('√Ç') || 
              result.contains('√Ü') || result.contains('√°¬∫')) {
            try {
              final bytes2 = latin1.encode(result);
              result = utf8.decode(bytes2, allowMalformed: true);
              print("üîç After second Latin-1 -> UTF-8: $result");
            } catch (e) {
              print('L·ªói second Latin-1 -> UTF-8: $e');
            }
          }
          
          // C√°ch 3: Th·ª≠ v·ªõi ISO-8859-1
          if (result.contains('√É') || result.contains('√Ç') || 
              result.contains('√Ü') || result.contains('√°¬∫')) {
            try {
              final bytes3 = latin1.encode(result);
              result = utf8.decode(bytes3, allowMalformed: true);
              print("üîç After ISO-8859-1 -> UTF-8: $result");
            } catch (e) {
              print('L·ªói ISO-8859-1 -> UTF-8: $e');
            }
          }
          
          decoded = result;
        }
      } catch (e) {
        print('L·ªói khi fix UTF-8 encoding: $e');
      }
      
      print("üîç Final decoded text: $decoded");
      return decoded;
    } catch (e) {
      print('L·ªói khi decode Unicode: $e');
      return text;
    }
  }
}
