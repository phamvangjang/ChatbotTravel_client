import 'dart:async';
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:geolocator/geolocator.dart';
import 'package:http/http.dart' as http;
import 'package:latlong2/latlong.dart';

import '../../models/attraction_model.dart';
import '../../models/itinerary_item.dart';
import '../../services/home/attraction_service.dart';

class MapViewModel extends ChangeNotifier {
  // Services
  //final LocationService _locationService = LocationService();
  final AttractionService _attractionService = AttractionService();

  // Mapbox access token
  final String mapboxAccessToken = dotenv.env["MAPBOX_ACCESS_TOKEN"]!;

  // Mapbox style URL
  final String mapboxStyleUrl = dotenv.env["MAPBOX_STYLE_URL_V2"]!;

  // Mapbox directions API URL
  final String directionsApiUrl = dotenv.env["DIRECTIONS_API_URL_V2"]!;

  // Tr·∫°ng th√°i
  bool _isLoading = true;
  bool get isLoading => _isLoading;

  // V·ªã tr√≠ hi·ªán t·∫°i
  Position? _currentPosition;
  Position? get currentPosition => _currentPosition;

  // V·ªã tr√≠ ban ƒë·∫ßu (m·∫∑c ƒë·ªãnh: H·ªì Ch√≠ Minh)
  LatLng _initialPosition = LatLng(10.7769, 106.7009);
  LatLng get initialPosition => _initialPosition;

  // N·ªôi dung tin nh·∫Øn
  String _messageContent = '';
  String get messageContent => _messageContent;

  // ID cu·ªôc tr√≤ chuy·ªán
  int _conversationId = 0;
  int get conversationId => _conversationId;

  // Danh s√°ch ƒë·ªãa ƒëi·ªÉm du l·ªãch
  List<Attraction> _detectedAttractions = [];
  List<Attraction> get detectedAttractions => _detectedAttractions;

  // ƒê·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn
  Attraction? _selectedAttraction;
  Attraction? get selectedAttraction => _selectedAttraction;

  // Markers tr√™n b·∫£n ƒë·ªì
  List<Marker> _markers = [];
  List<Marker> get markers => _markers;

  // Polylines tr√™n b·∫£n ƒë·ªì
  List<Polyline> _polylines = [];
  List<Polyline> get polylines => _polylines;

  // L·ªãch tr√¨nh theo ng√†y
  final Map<DateTime, List<ItineraryItem>> _dailyItineraries = {};
  Map<DateTime, List<ItineraryItem>> get dailyItineraries => _dailyItineraries;

  // Ng√†y ƒë∆∞·ª£c ch·ªçn
  DateTime _selectedDate = DateTime.now();
  DateTime get selectedDate => _selectedDate;

  // L·ªãch tr√¨nh c·ªßa ng√†y ƒë∆∞·ª£c ch·ªçn
  List<ItineraryItem> get todayItinerary {
    final dateKey = DateTime(
      _selectedDate.year,
      _selectedDate.month,
      _selectedDate.day,
    );
    return _dailyItineraries[dateKey] ?? [];
  }

  // Controller cho MapboxMap
  MapController? _mapController;
  MapController? get mapController => _mapController;

  bool _isMapControllerActive = true;
  // Ph∆∞∆°ng th·ª©c ƒë·ªÉ ki·ªÉm tra v√† ƒë·∫∑t l·∫°i controller
  void setMapControllerActive(bool isActive) {
    _isMapControllerActive = isActive;
    if (!isActive && _mapController != null) {
      // ƒê·∫∑t l·∫°i controller khi widget b·ªã h·ªßy
      _mapController = null;
    }
  }

  // Kh·ªüi t·∫°o
  Future<void> initialize(String messageContent, int conversationId) async {
    _messageContent = messageContent;
    _conversationId = conversationId;
    _isLoading = true;
    notifyListeners();

    // T·∫°o MapController
    _mapController = MapController();

    // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
    await _getCurrentLocationAndSetInitial();

    // Ph√°t hi·ªán ƒë·ªãa ƒëi·ªÉm t·ª´ n·ªôi dung tin nh·∫Øn
    await _detectAttractionsFromMessage();

    _isLoading = false;
    notifyListeners();
  }

  Future<void> _getCurrentLocationAndSetInitial() async{
    try{
      print('üîç ƒêang l·∫•y v·ªã tr√≠ hi·ªán t·∫°i...');

      // Ki·ªÉm tra quy·ªÅn truy c·∫≠p v·ªã tr√≠
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('‚ùå Quy·ªÅn truy c·∫≠p v·ªã tr√≠ b·ªã t·ª´ ch·ªëi');
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('‚ùå Quy·ªÅn truy c·∫≠p v·ªã tr√≠ b·ªã t·ª´ ch·ªëi vƒ©nh vi·ªÖn');
        return;
      }

      /*
      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i v·ªõi ƒë·ªô ch√≠nh x√°c cao
      _currentPosition = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: Duration(seconds: 10),
      );
       */
      // S·ª≠ d·ª•ng LocationSettings m·ªõi
      LocationSettings locationSettings = LocationSettings(
        accuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10)
      );

      _currentPosition = await Geolocator.getCurrentPosition(
        locationSettings: locationSettings,
      );

      if (_currentPosition != null) {
        _initialPosition = LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );

        print('‚úÖ ƒê√£ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}');
        print('üìç V·ªã tr√≠ ban ƒë·∫ßu ƒë∆∞·ª£c c·∫≠p nh·∫≠t: $_initialPosition');
      } else {
        print('‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i, s·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh');
      }
    }catch (e) {
      print('‚ùå L·ªói khi l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: $e');
      print('üìç S·ª≠ d·ª•ng v·ªã tr√≠ m·∫∑c ƒë·ªãnh: $_initialPosition');
    }
  }

  // Ph√°t hi·ªán ƒë·ªãa ƒëi·ªÉm t·ª´ n·ªôi dung tin nh·∫Øn
  Future<void> _detectAttractionsFromMessage() async {
    try {
      if (_messageContent.isNotEmpty) {
        _detectedAttractions = await _attractionService
            .detectAttractionsFromMessage(_messageContent);
        print("‚ÑπÔ∏è _detectAttractionsFromMessage: get location from messages");
      } else {
        // N·∫øu kh√¥ng c√≥ tin nh·∫Øn, l·∫•y ƒë·ªãa ƒëi·ªÉm g·∫ßn ƒë√≥
        if (_currentPosition != null) {
          LatLng currentLatLng = LatLng(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          );
          _detectedAttractions = await _attractionService.getNearbyAttractions(
            currentLatLng,
          );
          print("‚ÑπÔ∏è _detectAttractionsFromMessage: nothing messages get getNearbyAttractions");
        } else {
          // L·∫•y t·∫•t c·∫£ ƒë·ªãa ƒëi·ªÉm
          print("‚ÑπÔ∏è _detectAttractionsFromMessage: get all location");
          _detectedAttractions = await _attractionService.getAllAttractions();
        }
      }

      // T·∫°o markers cho c√°c ƒë·ªãa ƒëi·ªÉm
      _updateMarkers();
    } catch (e) {
      print('Error detecting attractions: $e');
      // Fallback: l·∫•y t·∫•t c·∫£ ƒë·ªãa ƒëi·ªÉm
      _detectedAttractions = await _attractionService.getAllAttractions();
      _updateMarkers();
    }
  }

  // C·∫≠p nh·∫≠t markers
  void _updateMarkers() {
    _markers = [];

    // Th√™m marker cho v·ªã tr√≠ hi·ªán t·∫°i
    if (_currentPosition != null) {
      _markers.add(
        Marker(
          point: LatLng(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          ),
          width: 40,
          height: 40,
          builder:
              (context) => Container(
                decoration: BoxDecoration(
                  color: Colors.blue,
                  shape: BoxShape.circle,
                  border: Border.all(color: Colors.white, width: 2),
                ),
                child: const Icon(
                  Icons.my_location,
                  color: Colors.white,
                  size: 20,
                ),
              ),
        ),
      );
    }

    // L·∫•y danh s√°ch c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh c·ªßa ng√†y h√¥m nay
    final itineraryItems = todayItinerary;
    final itineraryAttractionIds = itineraryItems.map((item) => item.attraction.id).toSet();

    // T·∫°o map ƒë·ªÉ l∆∞u tr·ªØ th·ª© t·ª± c·ªßa c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh
    final Map<String, int> attractionOrder = {};
    for (int i = 0; i < itineraryItems.length; i++) {
      attractionOrder[itineraryItems[i].attraction.id] = i + 1;
    }

    // Th√™m markers cho c√°c ƒë·ªãa ƒëi·ªÉm
    for (var attraction in _detectedAttractions) {
      final isSelected = _selectedAttraction?.id == attraction.id;
      final isInItinerary = itineraryAttractionIds.contains(attraction.id);
      final orderNumber = isInItinerary ? attractionOrder[attraction.id] : null;

      _markers.add(
        Marker(
          point: attraction.location,
          width: 40,
          height: 40,
          builder: (context) => GestureDetector(
            onTap: () => selectAttraction(attraction),
            child: Container(
              decoration: BoxDecoration(
                color: isSelected
                    ? Colors.green
                    : isInItinerary
                    ? Colors.orange
                    : Colors.red,
                shape: BoxShape.circle,
                border: Border.all(color: Colors.white, width: 2),
              ),
              child: isInItinerary
                  ? Stack(
                alignment: Alignment.center,
                children: [
                  Icon(
                    Icons.schedule,
                    color: Colors.white,
                    size: isSelected ? 20 : 16,
                  ),
                  Positioned(
                    top: 2,
                    right: 2,
                    child: Container(
                      padding: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        shape: BoxShape.circle,
                      ),
                      child: Text(
                        '$orderNumber',
                        style: TextStyle(
                          color: Colors.orange,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              )
                  : Icon(
                Icons.location_on,
                color: Colors.white,
                size: isSelected ? 24 : 20,
              ),
            ),
          ),
        ),
      );
    }

    // Th√™m markers cho c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh m√† kh√¥ng c√≥ trong k·∫øt qu·∫£ t√¨m ki·∫øm
    final searchAttractionIds = _detectedAttractions.map((a) => a.id).toSet();
    for (var item in itineraryItems) {
      // N·∫øu ƒë·ªãa ƒëi·ªÉm ƒë√£ c√≥ trong k·∫øt qu·∫£ t√¨m ki·∫øm th√¨ b·ªè qua
      if (searchAttractionIds.contains(item.attraction.id)) continue;

      final isSelected = _selectedAttraction?.id == item.attraction.id;
      final orderNumber = attractionOrder[item.attraction.id];

      _markers.add(
        Marker(
          point: item.attraction.location,
          width: 40,
          height: 40,
          builder: (context) => GestureDetector(
            onTap: () => selectAttraction(item.attraction),
            child: Container(
              decoration: BoxDecoration(
                color: isSelected ? Colors.green : Colors.orange,
                shape: BoxShape.circle,
                border: Border.all(color: Colors.white, width: 2),
              ),
              child: Stack(
                alignment: Alignment.center,
                children: [
                  Icon(
                    Icons.schedule,
                    color: Colors.white,
                    size: isSelected ? 20 : 16,
                  ),
                  Positioned(
                    top: 2,
                    right: 2,
                    child: Container(
                      padding: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        shape: BoxShape.circle,
                      ),
                      child: Text(
                        '$orderNumber',
                        style: TextStyle(
                          color: Colors.orange,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    notifyListeners();
  }

  // Ki·ªÉm tra ƒë·ªãa ƒëi·ªÉm c√≥ trong l·ªãch tr√¨nh h√¥m nay kh√¥ng
  bool _isAttractionInTodayItinerary(Attraction attraction) {
    return todayItinerary.any((item) => item.attraction.id == attraction.id);
  }

  // Ch·ªçn ƒë·ªãa ƒëi·ªÉm
  Future<void> selectAttraction(Attraction attraction) async {
    _selectedAttraction = attraction;
    _updateMarkers();

    // Di chuy·ªÉn b·∫£n ƒë·ªì ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn
    if (_mapController != null && _isMapControllerActive) {
      try {
        _mapController!.move(attraction.location, 15.0);
      } catch (e) {
        print('‚ùå L·ªói khi di chuy·ªÉn b·∫£n ƒë·ªì: $e');
        _mapController = null;
      }
    }

    // V·∫Ω ƒë∆∞·ªùng ƒëi t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn
    if (_currentPosition != null) {
      await _getDirections(
        LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
        attraction.location,
      );
    }

    notifyListeners();
  }

  // L·∫•y ch·ªâ ƒë∆∞·ªùng t·ª´ Mapbox API
  Future<void> _getDirections(LatLng start, LatLng end) async {
    try {
      final response = await http.get(
        Uri.parse(
          '$directionsApiUrl/${start.longitude},${start.latitude};${end.longitude},${end.latitude}?geometries=geojson&access_token=$mapboxAccessToken',
        ),
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);

        if (data['routes'] != null && data['routes'].isNotEmpty) {
          final route = data['routes'][0];
          final geometry = route['geometry'];

          if (geometry != null && geometry['coordinates'] != null) {
            final List<dynamic> coords = geometry['coordinates'];
            final List<LatLng> points =
                coords.map((coord) {
                  return LatLng(coord[1], coord[0]);
                }).toList();

            _polylines = [
              Polyline(points: points, color: Colors.blue, strokeWidth: 4.0),
            ];

            notifyListeners();
          }
        }
      }
    } catch (e) {
      print('Error getting directions: $e');
    }
  }

  // V·∫º ƒê∆Ø·ªúNG N·ªêI C√ÅC ƒê·ªäA ƒêI·ªÇM TRONG L·ªäCH TR√åNH
  Future<void> _drawItineraryRoute() async {
    try {
      final itinerary = todayItinerary;
      if (itinerary.length < 2) {
        // N·∫øu √≠t h∆°n 2 ƒë·ªãa ƒëi·ªÉm, ch·ªâ v·∫Ω t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒë·ªãa ƒëi·ªÉm ƒë·∫ßu ti√™n
        if (itinerary.length == 1 && _currentPosition != null) {
          await _getDirections(
            LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
            itinerary.first.attraction.location,
          );
        }
        return;
      }

      print('üó∫Ô∏è ƒêang v·∫Ω tuy·∫øn ƒë∆∞·ªùng cho ${itinerary.length} ƒë·ªãa ƒëi·ªÉm...');

      List<Polyline> itineraryPolylines = [];

      // T·∫°o danh s√°ch c√°c ƒëi·ªÉm theo th·ª© t·ª± th·ªùi gian
      List<LatLng> waypoints = [];

      // Th√™m v·ªã tr√≠ hi·ªán t·∫°i l√†m ƒëi·ªÉm b·∫Øt ƒë·∫ßu (n·∫øu c√≥)
      if (_currentPosition != null) {
        waypoints.add(LatLng(_currentPosition!.latitude, _currentPosition!.longitude));
      }

      // Th√™m c√°c ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh theo th·ª© t·ª± th·ªùi gian
      for (var item in itinerary) {
        waypoints.add(item.attraction.location);
      }

      // V·∫Ω ƒë∆∞·ªùng n·ªëi t·ª´ng c·∫∑p ƒëi·ªÉm li√™n ti·∫øp
      for (int i = 0; i < waypoints.length - 1; i++) {
        final start = waypoints[i];
        final end = waypoints[i + 1];

        try {
          final response = await http.get(
            Uri.parse(
              '$directionsApiUrl/${start.longitude},${start.latitude};${end.longitude},${end.latitude}?geometries=geojson&access_token=$mapboxAccessToken',
            ),
          );

          if (response.statusCode == 200) {
            final data = json.decode(response.body);

            if (data['routes'] != null && data['routes'].isNotEmpty) {
              final route = data['routes'][0];
              final geometry = route['geometry'];

              if (geometry != null && geometry['coordinates'] != null) {
                final List<dynamic> coords = geometry['coordinates'];
                final List<LatLng> points = coords.map((coord) {
                  return LatLng(coord[1], coord[0]);
                }).toList();

                // M√†u s·∫Øc kh√°c nhau cho t·ª´ng ƒëo·∫°n ƒë∆∞·ªùng
                Color segmentColor;
                if (i == 0 && _currentPosition != null) {
                  segmentColor = Colors.blue; // T·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒëi·ªÉm ƒë·∫ßu ti√™n
                } else {
                  segmentColor = Colors.green; // Gi·ªØa c√°c ƒëi·ªÉm trong l·ªãch tr√¨nh
                }

                itineraryPolylines.add(
                  Polyline(
                    points: points,
                    color: segmentColor,
                    strokeWidth: 4.0,
                  ),
                );
              }
            }
          }
        } catch (e) {
          print('‚ùå L·ªói v·∫Ω ƒë∆∞·ªùng ƒëo·∫°n ${i + 1}: $e');
        }

        // Delay nh·ªè ƒë·ªÉ tr√°nh spam API
        await Future.delayed(Duration(milliseconds: 200));
      }

      _polylines = itineraryPolylines;
      print('‚úÖ ƒê√£ v·∫Ω ${itineraryPolylines.length} ƒëo·∫°n ƒë∆∞·ªùng');
      notifyListeners();

    } catch (e) {
      print('‚ùå L·ªói v·∫Ω tuy·∫øn ƒë∆∞·ªùng l·ªãch tr√¨nh: $e');
    }
  }

  // Kh·ªüi t·∫°o MapController
  void onMapCreated() {
    _mapController ??= MapController();
    _isMapControllerActive = true;
    notifyListeners();
  }

  // Ch·ªçn ng√†y
  void selectDate(DateTime date) {
    _selectedDate = date;
    // C·∫≠p nh·∫≠t markers ƒë·ªÉ hi·ªÉn th·ªã ƒë·ªãa ƒëi·ªÉm trong l·ªãch tr√¨nh ng√†y ƒë∆∞·ª£c ch·ªçn
    _updateMarkers();
    // V·∫Ω l·∫°i ƒë∆∞·ªùng ƒëi cho ng√†y ƒë∆∞·ª£c ch·ªçn
    _drawItineraryRoute();
    notifyListeners();
  }

  // Th√™m v√†o l·ªãch tr√¨nh
  void addToItinerary(
    Attraction attraction, {
    required DateTime date,
    required TimeOfDay time,
  }) {
    final dateKey = DateTime(date.year, date.month, date.day);
    final visitTime = DateTime(
      date.year,
      date.month,
      date.day,
      time.hour,
      time.minute,
    );

    final item = ItineraryItem(attraction: attraction, visitTime: visitTime);

    if (_dailyItineraries.containsKey(dateKey)) {
      _dailyItineraries[dateKey]!.add(item);
      // S·∫Øp x·∫øp theo th·ªùi gian
      _dailyItineraries[dateKey]!.sort(
        (a, b) => a.visitTime.compareTo(b.visitTime),
      );
    } else {
      _dailyItineraries[dateKey] = [item];
    }

    // C·∫≠p nh·∫≠t markers
    _updateMarkers();

    // V·∫º ƒê∆Ø·ªúNG N·ªêI C√ÅC ƒê·ªäA ƒêI·ªÇM TRONG L·ªäCH TR√åNH
    if (dateKey == DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day)) {
      _drawItineraryRoute();
    }

    print('‚úÖ ƒê√£ th√™m ${attraction.name} v√†o l·ªãch tr√¨nh ng√†y ${date.day}/${date.month}');

    notifyListeners();
  }

  // X√≥a kh·ªèi l·ªãch tr√¨nh
  void removeFromItinerary(ItineraryItem item) {
    final dateKey = DateTime(
      item.visitTime.year,
      item.visitTime.month,
      item.visitTime.day,
    );

    if (_dailyItineraries.containsKey(dateKey)) {
      _dailyItineraries[dateKey]!.remove(item);

      if (_dailyItineraries[dateKey]!.isEmpty) {
        _dailyItineraries.remove(dateKey);
      }

      // C·∫≠p nh·∫≠t markers
      _updateMarkers();

      // V·∫Ω l·∫°i ƒë∆∞·ªùng ƒëi
      if (dateKey == DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day)) {
        _drawItineraryRoute();
      }

      notifyListeners();
    }
  }

  // C·∫≠p nh·∫≠t item trong l·ªãch tr√¨nh
  void updateItineraryItem(ItineraryItem oldItem, ItineraryItem newItem) {
    final oldDateKey = DateTime(
      oldItem.visitTime.year,
      oldItem.visitTime.month,
      oldItem.visitTime.day,
    );
    final newDateKey = DateTime(
      newItem.visitTime.year,
      newItem.visitTime.month,
      newItem.visitTime.day,
    );

    // X√≥a item c≈©
    if (_dailyItineraries.containsKey(oldDateKey)) {
      _dailyItineraries[oldDateKey]!.remove(oldItem);

      if (_dailyItineraries[oldDateKey]!.isEmpty) {
        _dailyItineraries.remove(oldDateKey);
      }
    }

    // Th√™m item m·ªõi
    if (_dailyItineraries.containsKey(newDateKey)) {
      _dailyItineraries[newDateKey]!.add(newItem);
      _dailyItineraries[newDateKey]!.sort(
        (a, b) => a.visitTime.compareTo(b.visitTime),
      );
    } else {
      _dailyItineraries[newDateKey] = [newItem];
    }

    // C·∫≠p nh·∫≠t markers v√† v·∫Ω l·∫°i ƒë∆∞·ªùng
    _updateMarkers();
    if (newDateKey == DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day)) {
      _drawItineraryRoute();
    }

    notifyListeners();
  }

  // S·∫Øp x·∫øp l·∫°i l·ªãch tr√¨nh
  void reorderItinerary(int oldIndex, int newIndex) {
    if (oldIndex < newIndex) {
      newIndex -= 1;
    }

    final dateKey = DateTime(
      _selectedDate.year,
      _selectedDate.month,
      _selectedDate.day,
    );

    if (_dailyItineraries.containsKey(dateKey)) {
      final item = _dailyItineraries[dateKey]!.removeAt(oldIndex);
      _dailyItineraries[dateKey]!.insert(newIndex, item);

      // V·∫Ω l·∫°i ƒë∆∞·ªùng sau khi s·∫Øp x·∫øp
      _drawItineraryRoute();

      notifyListeners();
    }
  }

  // L∆∞u l·ªãch tr√¨nh
  Future<bool> saveItinerary() async {
    try {
      // TODO: Implement saving itinerary to backend
      await Future.delayed(const Duration(seconds: 1));
      return true;
    } catch (e) {
      print('Error saving itinerary: $e');
      return false;
    }
  }

  // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i (public method)
  Future<void> getCurrentLocation() async {
    _isLoading = true;
    notifyListeners();

    await _getCurrentLocationAndSetInitial();
    _updateMarkers();

    // Di chuy·ªÉn b·∫£n ƒë·ªì ƒë·∫øn v·ªã tr√≠ hi·ªán t·∫°i
    if (_currentPosition != null && _mapController != null && _isMapControllerActive) {
      try {
        _mapController!.move(
          LatLng(_currentPosition!.latitude, _currentPosition!.longitude),
          15.0,
        );
      } catch (e) {
        print('‚ùå L·ªói khi di chuy·ªÉn b·∫£n ƒë·ªì: $e');
        // ƒê·∫∑t l·∫°i controller v√¨ n√≥ kh√¥ng c√≤n h·ª£p l·ªá
        _mapController = null;
      }
    }

    _isLoading = false;
    notifyListeners();
  }

  // T√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm
  Future<void> searchAttractions(String query) async {
    try {
      _isLoading = true;
      notifyListeners();

      LatLng? currentLocation;
      if (_currentPosition != null) {
        currentLocation = LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );
      }

      /*
      _detectedAttractions = await _attractionService.searchAttractions(
        query,
        currentLocation: currentLocation,
      );
      _updateMarkers();
       */
      // Get the search results
      List<Attraction> searchResults = await _attractionService.searchAttractions(
        query,
        currentLocation: currentLocation,
      );

      // Create a map of attraction IDs that are in the itinerary across all dates
      final Set<String> attractionsInItinerary = {};
      _dailyItineraries.forEach((date, items) {
        for (var item in items) {
          attractionsInItinerary.add(item.attraction.id);
        }
      });

      // Update the attractions list with search results
      _detectedAttractions = searchResults;

      // Update markers while preserving itinerary state
      _updateMarkers();

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      print('Error searching attractions: $e');
      _isLoading = false;
      notifyListeners();
    }
  }

  // L·∫•y ƒë·ªãa ƒëi·ªÉm theo danh m·ª•c
  Future<void> getAttractionsByCategory(String category) async {
    try {
      _isLoading = true;
      notifyListeners();

      LatLng? currentLocation;
      if (_currentPosition != null) {
        currentLocation = LatLng(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
        );
      }

      _detectedAttractions = await _attractionService.getAttractionsByCategory(
        category,
        currentLocation: currentLocation,
      );
      _updateMarkers();

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      print('Error getting attractions by category: $e');
      _isLoading = false;
      notifyListeners();
    }
  }

  // Reset selection
  void clearSelection() {
    _selectedAttraction = null;
    _polylines = [];
    _updateMarkers();
  }
}
